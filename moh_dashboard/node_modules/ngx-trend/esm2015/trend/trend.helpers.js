/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { normalize } from '../helpers/math.helpers';
/**
 * @param {?} data
 * @param {?} minX
 * @param {?} maxX
 * @param {?} minY
 * @param {?} maxY
 * @return {?}
 */
export function normalizeDataset(data, minX, maxX, minY, maxY) {
    // For the X axis, we want to normalize it based on its index in the array.
    // For the Y axis, we want to normalize it based on the element's value.
    //
    // X axis is easy: just evenly-space each item in the array.
    // For the Y axis, we first need to find the min and max of our array,
    // and then normalize those values between 0 and 1.
    /** @type {?} */
    const boundariesX = { min: 0, max: data.length - 1 };
    /** @type {?} */
    const boundariesY = { min: Math.min(...data), max: Math.max(...data) };
    /** @type {?} */
    const normalizedData = data.map((point, index) => ({
        x: normalize(index, boundariesX.min, boundariesX.max, minX, maxX),
        y: normalize(point, boundariesY.min, boundariesY.max, minY, maxY),
    }));
    // According to the SVG spec, paths with a height/width of `0` can't have
    // linear gradients applied. This means that our lines are invisible when
    // the dataset is flat (eg. [0, 0, 0, 0]).
    //
    // The hacky solution is to apply a very slight offset to the first point of
    // the dataset. As ugly as it is, it's the best solution we can find (there
    // are ways within the SVG spec of changing it, but not without causing
    // breaking changes).
    if (boundariesY.min === boundariesY.max) {
        normalizedData[0].y += 0.0001;
    }
    return normalizedData;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlbmQuaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC10cmVuZC8iLCJzb3VyY2VzIjpbInRyZW5kL3RyZW5kLmhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7Ozs7Ozs7O0FBRXBELE1BQU0sVUFBVSxnQkFBZ0IsQ0FDOUIsSUFBYyxFQUNkLElBQVksRUFDWixJQUFZLEVBQ1osSUFBWSxFQUNaLElBQVk7Ozs7Ozs7O1VBUU4sV0FBVyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7O1VBQzlDLFdBQVcsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRTs7VUFFaEUsY0FBYyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ2pELENBQUMsRUFBRSxTQUFTLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDO1FBQ2pFLENBQUMsRUFBRSxTQUFTLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDO0tBQ2xFLENBQUMsQ0FBQztJQUVILHlFQUF5RTtJQUN6RSx5RUFBeUU7SUFDekUsMENBQTBDO0lBQzFDLEVBQUU7SUFDRiw0RUFBNEU7SUFDNUUsMkVBQTJFO0lBQzNFLHVFQUF1RTtJQUN2RSxxQkFBcUI7SUFDckIsSUFBSSxXQUFXLENBQUMsR0FBRyxLQUFLLFdBQVcsQ0FBQyxHQUFHLEVBQUU7UUFDdkMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUM7S0FDL0I7SUFFRCxPQUFPLGNBQWMsQ0FBQztBQUN4QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbm9ybWFsaXplIH0gZnJvbSAnLi4vaGVscGVycy9tYXRoLmhlbHBlcnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRGF0YXNldChcbiAgZGF0YTogbnVtYmVyW10sXG4gIG1pblg6IG51bWJlcixcbiAgbWF4WDogbnVtYmVyLFxuICBtaW5ZOiBudW1iZXIsXG4gIG1heFk6IG51bWJlcixcbikge1xuICAvLyBGb3IgdGhlIFggYXhpcywgd2Ugd2FudCB0byBub3JtYWxpemUgaXQgYmFzZWQgb24gaXRzIGluZGV4IGluIHRoZSBhcnJheS5cbiAgLy8gRm9yIHRoZSBZIGF4aXMsIHdlIHdhbnQgdG8gbm9ybWFsaXplIGl0IGJhc2VkIG9uIHRoZSBlbGVtZW50J3MgdmFsdWUuXG4gIC8vXG4gIC8vIFggYXhpcyBpcyBlYXN5OiBqdXN0IGV2ZW5seS1zcGFjZSBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LlxuICAvLyBGb3IgdGhlIFkgYXhpcywgd2UgZmlyc3QgbmVlZCB0byBmaW5kIHRoZSBtaW4gYW5kIG1heCBvZiBvdXIgYXJyYXksXG4gIC8vIGFuZCB0aGVuIG5vcm1hbGl6ZSB0aG9zZSB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxLlxuICBjb25zdCBib3VuZGFyaWVzWCA9IHsgbWluOiAwLCBtYXg6IGRhdGEubGVuZ3RoIC0gMSB9O1xuICBjb25zdCBib3VuZGFyaWVzWSA9IHsgbWluOiBNYXRoLm1pbiguLi5kYXRhKSwgbWF4OiBNYXRoLm1heCguLi5kYXRhKSB9O1xuXG4gIGNvbnN0IG5vcm1hbGl6ZWREYXRhID0gZGF0YS5tYXAoKHBvaW50LCBpbmRleCkgPT4gKHtcbiAgICB4OiBub3JtYWxpemUoaW5kZXgsIGJvdW5kYXJpZXNYLm1pbiwgYm91bmRhcmllc1gubWF4LCBtaW5YLCBtYXhYKSxcbiAgICB5OiBub3JtYWxpemUocG9pbnQsIGJvdW5kYXJpZXNZLm1pbiwgYm91bmRhcmllc1kubWF4LCBtaW5ZLCBtYXhZKSxcbiAgfSkpO1xuXG4gIC8vIEFjY29yZGluZyB0byB0aGUgU1ZHIHNwZWMsIHBhdGhzIHdpdGggYSBoZWlnaHQvd2lkdGggb2YgYDBgIGNhbid0IGhhdmVcbiAgLy8gbGluZWFyIGdyYWRpZW50cyBhcHBsaWVkLiBUaGlzIG1lYW5zIHRoYXQgb3VyIGxpbmVzIGFyZSBpbnZpc2libGUgd2hlblxuICAvLyB0aGUgZGF0YXNldCBpcyBmbGF0IChlZy4gWzAsIDAsIDAsIDBdKS5cbiAgLy9cbiAgLy8gVGhlIGhhY2t5IHNvbHV0aW9uIGlzIHRvIGFwcGx5IGEgdmVyeSBzbGlnaHQgb2Zmc2V0IHRvIHRoZSBmaXJzdCBwb2ludCBvZlxuICAvLyB0aGUgZGF0YXNldC4gQXMgdWdseSBhcyBpdCBpcywgaXQncyB0aGUgYmVzdCBzb2x1dGlvbiB3ZSBjYW4gZmluZCAodGhlcmVcbiAgLy8gYXJlIHdheXMgd2l0aGluIHRoZSBTVkcgc3BlYyBvZiBjaGFuZ2luZyBpdCwgYnV0IG5vdCB3aXRob3V0IGNhdXNpbmdcbiAgLy8gYnJlYWtpbmcgY2hhbmdlcykuXG4gIGlmIChib3VuZGFyaWVzWS5taW4gPT09IGJvdW5kYXJpZXNZLm1heCkge1xuICAgIG5vcm1hbGl6ZWREYXRhWzBdLnkgKz0gMC4wMDAxO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWREYXRhO1xufVxuIl19