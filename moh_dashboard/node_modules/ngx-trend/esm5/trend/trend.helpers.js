/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { normalize } from '../helpers/math.helpers';
/**
 * @param {?} data
 * @param {?} minX
 * @param {?} maxX
 * @param {?} minY
 * @param {?} maxY
 * @return {?}
 */
export function normalizeDataset(data, minX, maxX, minY, maxY) {
    // For the X axis, we want to normalize it based on its index in the array.
    // For the Y axis, we want to normalize it based on the element's value.
    //
    // X axis is easy: just evenly-space each item in the array.
    // For the Y axis, we first need to find the min and max of our array,
    // and then normalize those values between 0 and 1.
    /** @type {?} */
    var boundariesX = { min: 0, max: data.length - 1 };
    /** @type {?} */
    var boundariesY = { min: Math.min.apply(Math, tslib_1.__spread(data)), max: Math.max.apply(Math, tslib_1.__spread(data)) };
    /** @type {?} */
    var normalizedData = data.map(function (point, index) { return ({
        x: normalize(index, boundariesX.min, boundariesX.max, minX, maxX),
        y: normalize(point, boundariesY.min, boundariesY.max, minY, maxY),
    }); });
    // According to the SVG spec, paths with a height/width of `0` can't have
    // linear gradients applied. This means that our lines are invisible when
    // the dataset is flat (eg. [0, 0, 0, 0]).
    //
    // The hacky solution is to apply a very slight offset to the first point of
    // the dataset. As ugly as it is, it's the best solution we can find (there
    // are ways within the SVG spec of changing it, but not without causing
    // breaking changes).
    if (boundariesY.min === boundariesY.max) {
        normalizedData[0].y += 0.0001;
    }
    return normalizedData;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlbmQuaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC10cmVuZC8iLCJzb3VyY2VzIjpbInRyZW5kL3RyZW5kLmhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0seUJBQXlCLENBQUM7Ozs7Ozs7OztBQUVwRCxNQUFNLFVBQVUsZ0JBQWdCLENBQzlCLElBQWMsRUFDZCxJQUFZLEVBQ1osSUFBWSxFQUNaLElBQVksRUFDWixJQUFZOzs7Ozs7OztRQVFOLFdBQVcsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFOztRQUM5QyxXQUFXLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsT0FBUixJQUFJLG1CQUFRLElBQUksRUFBQyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxPQUFSLElBQUksbUJBQVEsSUFBSSxFQUFDLEVBQUU7O1FBRWhFLGNBQWMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQUMsS0FBSyxFQUFFLEtBQUssSUFBSyxPQUFBLENBQUM7UUFDakQsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUM7UUFDakUsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUM7S0FDbEUsQ0FBQyxFQUhnRCxDQUdoRCxDQUFDO0lBRUgseUVBQXlFO0lBQ3pFLHlFQUF5RTtJQUN6RSwwQ0FBMEM7SUFDMUMsRUFBRTtJQUNGLDRFQUE0RTtJQUM1RSwyRUFBMkU7SUFDM0UsdUVBQXVFO0lBQ3ZFLHFCQUFxQjtJQUNyQixJQUFJLFdBQVcsQ0FBQyxHQUFHLEtBQUssV0FBVyxDQUFDLEdBQUcsRUFBRTtRQUN2QyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQztLQUMvQjtJQUVELE9BQU8sY0FBYyxDQUFDO0FBQ3hCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuLi9oZWxwZXJzL21hdGguaGVscGVycyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVEYXRhc2V0KFxuICBkYXRhOiBudW1iZXJbXSxcbiAgbWluWDogbnVtYmVyLFxuICBtYXhYOiBudW1iZXIsXG4gIG1pblk6IG51bWJlcixcbiAgbWF4WTogbnVtYmVyLFxuKSB7XG4gIC8vIEZvciB0aGUgWCBheGlzLCB3ZSB3YW50IHRvIG5vcm1hbGl6ZSBpdCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gdGhlIGFycmF5LlxuICAvLyBGb3IgdGhlIFkgYXhpcywgd2Ugd2FudCB0byBub3JtYWxpemUgaXQgYmFzZWQgb24gdGhlIGVsZW1lbnQncyB2YWx1ZS5cbiAgLy9cbiAgLy8gWCBheGlzIGlzIGVhc3k6IGp1c3QgZXZlbmx5LXNwYWNlIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuXG4gIC8vIEZvciB0aGUgWSBheGlzLCB3ZSBmaXJzdCBuZWVkIHRvIGZpbmQgdGhlIG1pbiBhbmQgbWF4IG9mIG91ciBhcnJheSxcbiAgLy8gYW5kIHRoZW4gbm9ybWFsaXplIHRob3NlIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEuXG4gIGNvbnN0IGJvdW5kYXJpZXNYID0geyBtaW46IDAsIG1heDogZGF0YS5sZW5ndGggLSAxIH07XG4gIGNvbnN0IGJvdW5kYXJpZXNZID0geyBtaW46IE1hdGgubWluKC4uLmRhdGEpLCBtYXg6IE1hdGgubWF4KC4uLmRhdGEpIH07XG5cbiAgY29uc3Qgbm9ybWFsaXplZERhdGEgPSBkYXRhLm1hcCgocG9pbnQsIGluZGV4KSA9PiAoe1xuICAgIHg6IG5vcm1hbGl6ZShpbmRleCwgYm91bmRhcmllc1gubWluLCBib3VuZGFyaWVzWC5tYXgsIG1pblgsIG1heFgpLFxuICAgIHk6IG5vcm1hbGl6ZShwb2ludCwgYm91bmRhcmllc1kubWluLCBib3VuZGFyaWVzWS5tYXgsIG1pblksIG1heFkpLFxuICB9KSk7XG5cbiAgLy8gQWNjb3JkaW5nIHRvIHRoZSBTVkcgc3BlYywgcGF0aHMgd2l0aCBhIGhlaWdodC93aWR0aCBvZiBgMGAgY2FuJ3QgaGF2ZVxuICAvLyBsaW5lYXIgZ3JhZGllbnRzIGFwcGxpZWQuIFRoaXMgbWVhbnMgdGhhdCBvdXIgbGluZXMgYXJlIGludmlzaWJsZSB3aGVuXG4gIC8vIHRoZSBkYXRhc2V0IGlzIGZsYXQgKGVnLiBbMCwgMCwgMCwgMF0pLlxuICAvL1xuICAvLyBUaGUgaGFja3kgc29sdXRpb24gaXMgdG8gYXBwbHkgYSB2ZXJ5IHNsaWdodCBvZmZzZXQgdG8gdGhlIGZpcnN0IHBvaW50IG9mXG4gIC8vIHRoZSBkYXRhc2V0LiBBcyB1Z2x5IGFzIGl0IGlzLCBpdCdzIHRoZSBiZXN0IHNvbHV0aW9uIHdlIGNhbiBmaW5kICh0aGVyZVxuICAvLyBhcmUgd2F5cyB3aXRoaW4gdGhlIFNWRyBzcGVjIG9mIGNoYW5naW5nIGl0LCBidXQgbm90IHdpdGhvdXQgY2F1c2luZ1xuICAvLyBicmVha2luZyBjaGFuZ2VzKS5cbiAgaWYgKGJvdW5kYXJpZXNZLm1pbiA9PT0gYm91bmRhcmllc1kubWF4KSB7XG4gICAgbm9ybWFsaXplZERhdGFbMF0ueSArPSAwLjAwMDE7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZERhdGE7XG59XG4iXX0=