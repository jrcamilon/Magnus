/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { checkForCollinearPoints, getDistanceBetween, moveTo, } from './math.helpers';
/** @type {?} */
export var buildLinearPath = function (data) {
    return data.reduce(function (path, point, index) {
        // The very first instruction needs to be a "move".
        // The rest will be a "line".
        /** @type {?} */
        var isFirstInstruction = index === 0;
        /** @type {?} */
        var instruction = isFirstInstruction ? 'M' : 'L';
        return "" + path + instruction + " " + point.x + "," + point.y + "\n";
    }, '');
};
/**
 * @param {?} data
 * @param {?} radius
 * @return {?}
 */
export function buildSmoothPath(data, radius) {
    var _a = tslib_1.__read(data), firstPoint = _a[0], otherPoints = _a.slice(1);
    return otherPoints.reduce(function (path, point, index) {
        /** @type {?} */
        var next = otherPoints[index + 1];
        /** @type {?} */
        var prev = otherPoints[index - 1] || firstPoint;
        /** @type {?} */
        var isCollinear = next && checkForCollinearPoints(prev, point, next);
        if (!next || isCollinear) {
            // The very last line in the sequence can just be a regular line.
            return path + "\nL " + point.x + "," + point.y;
        }
        /** @type {?} */
        var distanceFromPrev = getDistanceBetween(prev, point);
        /** @type {?} */
        var distanceFromNext = getDistanceBetween(next, point);
        /** @type {?} */
        var threshold = Math.min(distanceFromPrev, distanceFromNext);
        /** @type {?} */
        var isTooCloseForRadius = threshold / 2 < radius;
        /** @type {?} */
        var radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;
        /** @type {?} */
        var before = moveTo(prev, point, radiusForPoint);
        /** @type {?} */
        var after = moveTo(next, point, radiusForPoint);
        return [
            path,
            "L " + before.x + "," + before.y,
            "S " + point.x + "," + point.y + " " + after.x + "," + after.y,
        ].join('\n');
    }, "M " + firstPoint.x + "," + firstPoint.y);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRE9NLmhlbHBlcnMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtdHJlbmQvIiwic291cmNlcyI6WyJoZWxwZXJzL0RPTS5oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixrQkFBa0IsRUFDbEIsTUFBTSxHQUVQLE1BQU0sZ0JBQWdCLENBQUM7O0FBRXhCLE1BQU0sS0FBTyxlQUFlLEdBQUcsVUFBQyxJQUFhO0lBQzNDLE9BQUEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsS0FBSzs7OztZQUd2QixrQkFBa0IsR0FBRyxLQUFLLEtBQUssQ0FBQzs7WUFDaEMsV0FBVyxHQUFHLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUc7UUFFbEQsT0FBTyxLQUFHLElBQUksR0FBRyxXQUFXLFNBQUksS0FBSyxDQUFDLENBQUMsU0FBSSxLQUFLLENBQUMsQ0FBQyxPQUFJLENBQUM7SUFDekQsQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQVBOLENBT007Ozs7OztBQUVSLE1BQU0sVUFBVSxlQUFlLENBQUMsSUFBYSxFQUFFLE1BQWM7SUFDckQsSUFBQSx5QkFBbUMsRUFBbEMsa0JBQVUsRUFBRSx5QkFBc0I7SUFFekMsT0FBTyxXQUFXLENBQUMsTUFBTSxDQUFDLFVBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxLQUFLOztZQUNyQyxJQUFJLEdBQUcsV0FBVyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7O1lBQzdCLElBQUksR0FBRyxXQUFXLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxJQUFJLFVBQVU7O1lBRTNDLFdBQVcsR0FBRyxJQUFJLElBQUksdUJBQXVCLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUM7UUFFdEUsSUFBSSxDQUFDLElBQUksSUFBSSxXQUFXLEVBQUU7WUFDeEIsaUVBQWlFO1lBQ2pFLE9BQVUsSUFBSSxZQUFPLEtBQUssQ0FBQyxDQUFDLFNBQUksS0FBSyxDQUFDLENBQUcsQ0FBQztTQUMzQzs7WUFFSyxnQkFBZ0IsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDOztZQUNsRCxnQkFBZ0IsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDOztZQUNsRCxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsRUFBRSxnQkFBZ0IsQ0FBQzs7WUFFeEQsbUJBQW1CLEdBQUcsU0FBUyxHQUFHLENBQUMsR0FBRyxNQUFNOztZQUU1QyxjQUFjLEdBQUcsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU07O1lBRTdELE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxjQUFjLENBQUM7O1lBQzVDLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxjQUFjLENBQUM7UUFFakQsT0FBTztZQUNMLElBQUk7WUFDSixPQUFLLE1BQU0sQ0FBQyxDQUFDLFNBQUksTUFBTSxDQUFDLENBQUc7WUFDM0IsT0FBSyxLQUFLLENBQUMsQ0FBQyxTQUFJLEtBQUssQ0FBQyxDQUFDLFNBQUksS0FBSyxDQUFDLENBQUMsU0FBSSxLQUFLLENBQUMsQ0FBRztTQUNoRCxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNmLENBQUMsRUFBRSxPQUFLLFVBQVUsQ0FBQyxDQUFDLFNBQUksVUFBVSxDQUFDLENBQUcsQ0FBQyxDQUFDO0FBQzFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBjaGVja0ZvckNvbGxpbmVhclBvaW50cyxcbiAgZ2V0RGlzdGFuY2VCZXR3ZWVuLFxuICBtb3ZlVG8sXG4gIFBvaW50LFxufSBmcm9tICcuL21hdGguaGVscGVycyc7XG5cbmV4cG9ydCBjb25zdCBidWlsZExpbmVhclBhdGggPSAoZGF0YTogUG9pbnRbXSkgPT5cbiAgZGF0YS5yZWR1Y2UoKHBhdGgsIHBvaW50LCBpbmRleCkgPT4ge1xuICAgIC8vIFRoZSB2ZXJ5IGZpcnN0IGluc3RydWN0aW9uIG5lZWRzIHRvIGJlIGEgXCJtb3ZlXCIuXG4gICAgLy8gVGhlIHJlc3Qgd2lsbCBiZSBhIFwibGluZVwiLlxuICAgIGNvbnN0IGlzRmlyc3RJbnN0cnVjdGlvbiA9IGluZGV4ID09PSAwO1xuICAgIGNvbnN0IGluc3RydWN0aW9uID0gaXNGaXJzdEluc3RydWN0aW9uID8gJ00nIDogJ0wnO1xuXG4gICAgcmV0dXJuIGAke3BhdGh9JHtpbnN0cnVjdGlvbn0gJHtwb2ludC54fSwke3BvaW50Lnl9XFxuYDtcbiAgfSwgJycpO1xuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTbW9vdGhQYXRoKGRhdGE6IFBvaW50W10sIHJhZGl1czogbnVtYmVyKSB7XG4gIGNvbnN0IFtmaXJzdFBvaW50LCAuLi5vdGhlclBvaW50c10gPSBkYXRhO1xuXG4gIHJldHVybiBvdGhlclBvaW50cy5yZWR1Y2UoKHBhdGgsIHBvaW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG5leHQgPSBvdGhlclBvaW50c1tpbmRleCArIDFdO1xuICAgIGNvbnN0IHByZXYgPSBvdGhlclBvaW50c1tpbmRleCAtIDFdIHx8IGZpcnN0UG9pbnQ7XG5cbiAgICBjb25zdCBpc0NvbGxpbmVhciA9IG5leHQgJiYgY2hlY2tGb3JDb2xsaW5lYXJQb2ludHMocHJldiwgcG9pbnQsIG5leHQpO1xuXG4gICAgaWYgKCFuZXh0IHx8IGlzQ29sbGluZWFyKSB7XG4gICAgICAvLyBUaGUgdmVyeSBsYXN0IGxpbmUgaW4gdGhlIHNlcXVlbmNlIGNhbiBqdXN0IGJlIGEgcmVndWxhciBsaW5lLlxuICAgICAgcmV0dXJuIGAke3BhdGh9XFxuTCAke3BvaW50Lnh9LCR7cG9pbnQueX1gO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc3RhbmNlRnJvbVByZXYgPSBnZXREaXN0YW5jZUJldHdlZW4ocHJldiwgcG9pbnQpO1xuICAgIGNvbnN0IGRpc3RhbmNlRnJvbU5leHQgPSBnZXREaXN0YW5jZUJldHdlZW4obmV4dCwgcG9pbnQpO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IE1hdGgubWluKGRpc3RhbmNlRnJvbVByZXYsIGRpc3RhbmNlRnJvbU5leHQpO1xuXG4gICAgY29uc3QgaXNUb29DbG9zZUZvclJhZGl1cyA9IHRocmVzaG9sZCAvIDIgPCByYWRpdXM7XG5cbiAgICBjb25zdCByYWRpdXNGb3JQb2ludCA9IGlzVG9vQ2xvc2VGb3JSYWRpdXMgPyB0aHJlc2hvbGQgLyAyIDogcmFkaXVzO1xuXG4gICAgY29uc3QgYmVmb3JlID0gbW92ZVRvKHByZXYsIHBvaW50LCByYWRpdXNGb3JQb2ludCk7XG4gICAgY29uc3QgYWZ0ZXIgPSBtb3ZlVG8obmV4dCwgcG9pbnQsIHJhZGl1c0ZvclBvaW50KTtcblxuICAgIHJldHVybiBbXG4gICAgICBwYXRoLFxuICAgICAgYEwgJHtiZWZvcmUueH0sJHtiZWZvcmUueX1gLFxuICAgICAgYFMgJHtwb2ludC54fSwke3BvaW50Lnl9ICR7YWZ0ZXIueH0sJHthZnRlci55fWAsXG4gICAgXS5qb2luKCdcXG4nKTtcbiAgfSwgYE0gJHtmaXJzdFBvaW50Lnh9LCR7Zmlyc3RQb2ludC55fWApO1xufVxuIl19