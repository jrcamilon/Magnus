(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/animations'), require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-trend', ['exports', '@angular/animations', '@angular/core', '@angular/common'], factory) :
    (factory((global['ngx-trend'] = {}),global.ng.animations,global.ng.core,global.ng.common));
}(this, (function (exports,animations,core,common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /* eslint-disable no-restricted-properties */
    /**
     * normalize
     * This lets us translate a value from one scale to another.
     *
     * @param {?} value - Our initial value to translate
     * @param {?} min - the current minimum value possible
     * @param {?} max - the current maximum value possible
     * @param {?=} scaleMin - the min value of the scale we're translating to
     * @param {?=} scaleMax - the max value of the scale we're translating to
     *
     * @return {?} the value on its new scale
     */
    function normalize(value, min, max, scaleMin, scaleMax) {
        if (scaleMin === void 0) {
            scaleMin = 0;
        }
        if (scaleMax === void 0) {
            scaleMax = 1;
        }
        // If the `min` and `max` are the same value, it means our dataset is flat.
        // For now, let's assume that flat data should be aligned to the bottom.
        if (min === max) {
            return scaleMin;
        }
        return scaleMin + (value - min) * (scaleMax - scaleMin) / (max - min);
    }
    /**
     * moveTo
     * the coordinate that lies at a midpoint between 2 lines, based on the radius
     *
     * @param {?} to - Our initial point
     * @param {?} from - Our final point
     * @param {?} radius - The distance away from the final point
     *
     * @return {?} an object holding the x/y coordinates of the midpoint.
     */
    function moveTo(to, from, radius) {
        /** @type {?} */
        var length = Math.sqrt((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y));
        /** @type {?} */
        var unitVector = { x: (to.x - from.x) / length, y: (to.y - from.y) / length };
        return {
            x: from.x + unitVector.x * radius,
            y: from.y + unitVector.y * radius,
        };
    }
    /**
     * getDistanceBetween
     * Simple formula derived from pythagoras to calculate the distance between
     * 2 points on a plane.
     *
     * \@param p1 - Our initial point
     * \@param p1.x - The x value of our initial point
     * \@param p1.y - The y value of our initial point
     * \@param p2 - Our final point
     * \@param p2.x - The x value of our final point
     * \@param p2.y - The y value of our final point
     *
     * \@return the distance between the points.
     * @type {?}
     */
    var getDistanceBetween = function (p1, p2) {
        return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
    };
    /**
     * checkForCollinearPoints
     * Figure out if the midpoint fits perfectly on a line between the two others.
     *
     * \@param p1 - Our initial point
     * \@param p1.x - The x value of our initial point
     * \@param p1.y - The y value of our initial point
     * \@param p2 - Our mid-point
     * \@param p2.x - The x value of our mid-point
     * \@param p2.y - The y value of our mid-point
     * \@param p3 - Our final point
     * \@param p3.x - The x value of our final point
     * \@param p3.y - The y value of our final point
     * \@return whether or not p2 sits on the line between p1 and p3.
     * @type {?}
     */
    var checkForCollinearPoints = function (p1, p2, p3) {
        return (p1.y - p2.y) * (p1.x - p3.x) === (p1.y - p3.y) * (p1.x - p2.x);
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var buildLinearPath = function (data) {
        return data.reduce(function (path, point, index) {
            // The very first instruction needs to be a "move".
            // The rest will be a "line".
            /** @type {?} */
            var isFirstInstruction = index === 0;
            /** @type {?} */
            var instruction = isFirstInstruction ? 'M' : 'L';
            return "" + path + instruction + " " + point.x + "," + point.y + "\n";
        }, '');
    };
    /**
     * @param {?} data
     * @param {?} radius
     * @return {?}
     */
    function buildSmoothPath(data, radius) {
        var _a = __read(data), firstPoint = _a[0], otherPoints = _a.slice(1);
        return otherPoints.reduce(function (path, point, index) {
            /** @type {?} */
            var next = otherPoints[index + 1];
            /** @type {?} */
            var prev = otherPoints[index - 1] || firstPoint;
            /** @type {?} */
            var isCollinear = next && checkForCollinearPoints(prev, point, next);
            if (!next || isCollinear) {
                // The very last line in the sequence can just be a regular line.
                return path + "\nL " + point.x + "," + point.y;
            }
            /** @type {?} */
            var distanceFromPrev = getDistanceBetween(prev, point);
            /** @type {?} */
            var distanceFromNext = getDistanceBetween(next, point);
            /** @type {?} */
            var threshold = Math.min(distanceFromPrev, distanceFromNext);
            /** @type {?} */
            var isTooCloseForRadius = threshold / 2 < radius;
            /** @type {?} */
            var radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;
            /** @type {?} */
            var before = moveTo(prev, point, radiusForPoint);
            /** @type {?} */
            var after = moveTo(next, point, radiusForPoint);
            return [
                path,
                "L " + before.x + "," + before.y,
                "S " + point.x + "," + point.y + " " + after.x + "," + after.y,
            ].join('\n');
        }, "M " + firstPoint.x + "," + firstPoint.y);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var generateId = function () { return Math.round(Math.random() * Math.pow(10, 16)); };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @param {?} data
     * @param {?} minX
     * @param {?} maxX
     * @param {?} minY
     * @param {?} maxY
     * @return {?}
     */
    function normalizeDataset(data, minX, maxX, minY, maxY) {
        // For the X axis, we want to normalize it based on its index in the array.
        // For the Y axis, we want to normalize it based on the element's value.
        //
        // X axis is easy: just evenly-space each item in the array.
        // For the Y axis, we first need to find the min and max of our array,
        // and then normalize those values between 0 and 1.
        /** @type {?} */
        var boundariesX = { min: 0, max: data.length - 1 };
        /** @type {?} */
        var boundariesY = { min: Math.min.apply(Math, __spread(data)), max: Math.max.apply(Math, __spread(data)) };
        /** @type {?} */
        var normalizedData = data.map(function (point, index) {
            return ({
                x: normalize(index, boundariesX.min, boundariesX.max, minX, maxX),
                y: normalize(point, boundariesY.min, boundariesY.max, minY, maxY),
            });
        });
        // According to the SVG spec, paths with a height/width of `0` can't have
        // linear gradients applied. This means that our lines are invisible when
        // the dataset is flat (eg. [0, 0, 0, 0]).
        //
        // The hacky solution is to apply a very slight offset to the first point of
        // the dataset. As ugly as it is, it's the best solution we can find (there
        // are ways within the SVG spec of changing it, but not without causing
        // breaking changes).
        if (boundariesY.min === boundariesY.max) {
            normalizedData[0].y += 0.0001;
        }
        return normalizedData;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TrendComponent = /** @class */ (function () {
        function TrendComponent() {
            this.autoDraw = false;
            this.autoDrawDuration = 2000;
            this.autoDrawEasing = 'ease';
            this.padding = 8;
            this.radius = 10;
            this.stroke = 'black';
            this.strokeLinecap = '';
            this.strokeWidth = 1;
            this.gradient = [];
            this.svgHeight = '25%';
            this.svgWidth = '100%';
            this.animationState = '';
            this.id = generateId();
            this.gradientId = "ngx-trend-vertical-gradient-" + this.id;
        }
        /**
         * @return {?}
         */
        TrendComponent.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // We need at least 2 points to draw a graph.
                if (!this.data || this.data.length < 2) {
                    return;
                }
                // `data` can either be an array of numbers:
                // [1, 2, 3]
                // or, an array of objects containing a value:
                // [{ value: 1 }, { value: 2 }, { value: 3 }]
                //
                // For now, we're just going to convert the second form to the first.
                // Later on, if/when we support tooltips, we may adjust.
                /** @type {?} */
                var plainValues = this.data.map(function (point) {
                    if (typeof point === 'number') {
                        return point;
                    }
                    return point.value;
                });
                // Our viewbox needs to be in absolute units, so we'll default to 300x75
                // Our SVG can be a %, though; this is what makes it scalable.
                // By defaulting to percentages, the SVG will grow to fill its parent
                // container, preserving a 1/4 aspect ratio.
                /** @type {?} */
                var viewBoxWidth = this.width || 300;
                /** @type {?} */
                var viewBoxHeight = this.height || 75;
                this.svgWidth = this.width || '100%';
                this.svgHeight = this.height || '25%';
                this.viewBox = "0 0 " + viewBoxWidth + " " + viewBoxHeight;
                /** @type {?} */
                var root = location.href.split(location.hash || '#')[0];
                this.pathStroke = (this.gradient && this.gradient.length) ? "url('" + root + "#" + this.gradientId + "')" : undefined;
                this.gradientTrimmed = this.gradient.slice().reverse().map(function (val, idx) {
                    return {
                        idx: idx,
                        stopColor: val,
                        offset: normalize(idx, 0, _this.gradient.length - 1 || 1),
                    };
                });
                /** @type {?} */
                var normalizedValues = normalizeDataset(plainValues, this.padding, viewBoxWidth - this.padding, 
                // NOTE: Because SVGs are indexed from the top left, but most data is
                // indexed from the bottom left, we're inverting the Y min/max.
                viewBoxHeight - this.padding, this.padding);
                if (this.autoDraw && this.animationState !== 'active') {
                    this.animationState = 'inactive';
                    setTimeout(function () {
                        _this.lineLength = _this.pathEl.nativeElement.getTotalLength();
                        _this.animationState = 'active';
                    });
                }
                this.d = this.smooth
                    ? buildSmoothPath(normalizedValues, this.radius)
                    : buildLinearPath(normalizedValues);
            };
        TrendComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-trend',
                        template: "\n  <svg *ngIf=\"data && data.length >= 2\"\n    [attr.width]=\"svgWidth\"\n    [attr.height]=\"svgHeight\"\n    [attr.stroke]=\"stroke\"\n    [attr.stroke-width]=\"strokeWidth\"\n    [attr.stroke-linecap]=\"strokeLinecap\"\n    [attr.viewBox]=\"viewBox\"\n    [attr.preserveAspectRatio]=\"preserveAspectRatio\"\n  >\n    <defs *ngIf=\"gradient && gradient.length\">\n      <linearGradient [attr.id]=\"gradientId\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n        <stop\n          *ngFor=\"let g of gradientTrimmed;\"\n          [attr.key]=\"g.idx\"\n          [attr.offset]=\"g.offset\"\n          [attr.stop-color]=\"g.stopColor\"\n        />\n      </linearGradient>\n    </defs>\n    <path fill=\"none\" #pathEl\n      [attr.stroke]=\"pathStroke\" [attr.d]=\"d\"\n      [@pathAnimaiton]=\"{\n        value: animationState,\n        params: {\n          autoDrawDuration: autoDrawDuration,\n          autoDrawEasing: autoDrawEasing,\n          lineLength: lineLength\n        }\n      }\" />\n  </svg>\n  ",
                        animations: [
                            animations.trigger('pathAnimaiton', [
                                animations.state('inactive', animations.style({ display: 'none' })),
                                animations.transition('* => active', [
                                    animations.style({ display: 'initial' }),
                                    // We do the animation using the dash array/offset trick
                                    // https://css-tricks.com/svg-line-animation-works/
                                    animations.animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', animations.keyframes([
                                        animations.style({
                                            'stroke-dasharray': '{{ lineLength }}px',
                                            'stroke-dashoffset': '{{ lineLength }}px',
                                        }),
                                        animations.style({
                                            'stroke-dasharray': '{{ lineLength }}px',
                                            'stroke-dashoffset': 0,
                                        }),
                                    ])),
                                    // One unfortunate side-effect of the auto-draw is that the line is
                                    // actually 1 big dash, the same length as the line itself. If the
                                    // line length changes (eg. radius change, new data), that dash won't
                                    // be the same length anymore. We can fix that by removing those
                                    // properties once the auto-draw is completed.
                                    animations.style({
                                        'stroke-dashoffset': '',
                                        'stroke-dasharray': '',
                                    }),
                                ]),
                            ]),
                        ]
                    }] }
        ];
        /** @nocollapse */
        TrendComponent.ctorParameters = function () { return []; };
        TrendComponent.propDecorators = {
            data: [{ type: core.Input }],
            smooth: [{ type: core.Input }],
            autoDraw: [{ type: core.Input }],
            autoDrawDuration: [{ type: core.Input }],
            autoDrawEasing: [{ type: core.Input }],
            width: [{ type: core.Input }],
            height: [{ type: core.Input }],
            padding: [{ type: core.Input }],
            radius: [{ type: core.Input }],
            stroke: [{ type: core.Input }],
            strokeLinecap: [{ type: core.Input }],
            strokeWidth: [{ type: core.Input }],
            gradient: [{ type: core.Input }],
            preserveAspectRatio: [{ type: core.Input }],
            svgHeight: [{ type: core.Input }],
            svgWidth: [{ type: core.Input }],
            pathEl: [{ type: core.ViewChild, args: ['pathEl',] }]
        };
        return TrendComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TrendModule = /** @class */ (function () {
        function TrendModule() {
        }
        TrendModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [TrendComponent],
                        declarations: [TrendComponent],
                    },] }
        ];
        return TrendModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.TrendComponent = TrendComponent;
    exports.TrendModule = TrendModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXRyZW5kLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJuZzovL25neC10cmVuZC9oZWxwZXJzL21hdGguaGVscGVycy50cyIsIm5nOi8vbmd4LXRyZW5kL2hlbHBlcnMvRE9NLmhlbHBlcnMudHMiLCJuZzovL25neC10cmVuZC9oZWxwZXJzL21pc2MuaGVscGVycy50cyIsIm5nOi8vbmd4LXRyZW5kL3RyZW5kL3RyZW5kLmhlbHBlcnMudHMiLCJuZzovL25neC10cmVuZC90cmVuZC90cmVuZC5jb21wb25lbnQudHMiLCJuZzovL25neC10cmVuZC90cmVuZC90cmVuZC5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXByb3BlcnRpZXMgKi9cblxuLyoqIG5vcm1hbGl6ZVxuICogVGhpcyBsZXRzIHVzIHRyYW5zbGF0ZSBhIHZhbHVlIGZyb20gb25lIHNjYWxlIHRvIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gT3VyIGluaXRpYWwgdmFsdWUgdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0gbWluIC0gdGhlIGN1cnJlbnQgbWluaW11bSB2YWx1ZSBwb3NzaWJsZVxuICogQHBhcmFtIG1heCAtIHRoZSBjdXJyZW50IG1heGltdW0gdmFsdWUgcG9zc2libGVcbiAqIEBwYXJhbSBzY2FsZU1pbiAtIHRoZSBtaW4gdmFsdWUgb2YgdGhlIHNjYWxlIHdlJ3JlIHRyYW5zbGF0aW5nIHRvXG4gKiBAcGFyYW0gc2NhbGVNYXggLSB0aGUgbWF4IHZhbHVlIG9mIHRoZSBzY2FsZSB3ZSdyZSB0cmFuc2xhdGluZyB0b1xuICpcbiAqIEByZXR1cm5zIHRoZSB2YWx1ZSBvbiBpdHMgbmV3IHNjYWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUoXG4gIHZhbHVlOiBudW1iZXIsXG4gIG1pbjogbnVtYmVyLFxuICBtYXg6IG51bWJlcixcbiAgc2NhbGVNaW4gPSAwLFxuICBzY2FsZU1heCA9IDEsXG4pIHtcbiAgLy8gSWYgdGhlIGBtaW5gIGFuZCBgbWF4YCBhcmUgdGhlIHNhbWUgdmFsdWUsIGl0IG1lYW5zIG91ciBkYXRhc2V0IGlzIGZsYXQuXG4gIC8vIEZvciBub3csIGxldCdzIGFzc3VtZSB0aGF0IGZsYXQgZGF0YSBzaG91bGQgYmUgYWxpZ25lZCB0byB0aGUgYm90dG9tLlxuICBpZiAobWluID09PSBtYXgpIHtcbiAgICByZXR1cm4gc2NhbGVNaW47XG4gIH1cblxuICByZXR1cm4gc2NhbGVNaW4gKyAodmFsdWUgLSBtaW4pICogKHNjYWxlTWF4IC0gc2NhbGVNaW4pIC8gKG1heCAtIG1pbik7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9pbnQge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbn1cblxuLyoqIG1vdmVUb1xuICogdGhlIGNvb3JkaW5hdGUgdGhhdCBsaWVzIGF0IGEgbWlkcG9pbnQgYmV0d2VlbiAyIGxpbmVzLCBiYXNlZCBvbiB0aGUgcmFkaXVzXG4gKlxuICogQHBhcmFtIHRvIC0gT3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSB0by54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSB0by55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBmcm9tIC0gT3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gZnJvbS54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gZnJvbS55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gcmFkaXVzIC0gVGhlIGRpc3RhbmNlIGF3YXkgZnJvbSB0aGUgZmluYWwgcG9pbnRcbiAqXG4gKiBAcmV0dXJucyBhbiBvYmplY3QgaG9sZGluZyB0aGUgeC95IGNvb3JkaW5hdGVzIG9mIHRoZSBtaWRwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdmVUbyh0bzogUG9pbnQsIGZyb206IFBvaW50LCByYWRpdXM6IG51bWJlcik6IFBvaW50IHtcbiAgY29uc3QgbGVuZ3RoID0gTWF0aC5zcXJ0KCh0by54IC0gZnJvbS54KSAqICh0by54IC0gZnJvbS54KSArICh0by55IC0gZnJvbS55KSAqICh0by55IC0gZnJvbS55KSk7XG4gIGNvbnN0IHVuaXRWZWN0b3IgPSB7IHg6ICh0by54IC0gZnJvbS54KSAvIGxlbmd0aCwgeTogKHRvLnkgLSBmcm9tLnkpIC8gbGVuZ3RoIH07XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBmcm9tLnggKyB1bml0VmVjdG9yLnggKiByYWRpdXMsXG4gICAgeTogZnJvbS55ICsgdW5pdFZlY3Rvci55ICogcmFkaXVzLFxuICB9O1xufVxuXG4vKiogZ2V0RGlzdGFuY2VCZXR3ZWVuXG4gKiBTaW1wbGUgZm9ybXVsYSBkZXJpdmVkIGZyb20gcHl0aGFnb3JhcyB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW5cbiAqIDIgcG9pbnRzIG9uIGEgcGxhbmUuXG4gKlxuICogQHBhcmFtIHAxIC0gT3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMS54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMS55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMiAtIE91ciBmaW5hbCBwb2ludFxuICogQHBhcmFtIHAyLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBwMi55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG4gKlxuICogQHJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldERpc3RhbmNlQmV0d2VlbiA9IChwMTogUG9pbnQsIHAyOiBQb2ludCkgPT5cbiAgTWF0aC5zcXJ0KE1hdGgucG93KHAyLnggLSBwMS54LCAyKSArIE1hdGgucG93KHAyLnkgLSBwMS55LCAyKSk7XG5cbi8qKiBjaGVja0ZvckNvbGxpbmVhclBvaW50c1xuICogRmlndXJlIG91dCBpZiB0aGUgbWlkcG9pbnQgZml0cyBwZXJmZWN0bHkgb24gYSBsaW5lIGJldHdlZW4gdGhlIHR3byBvdGhlcnMuXG4gKlxuICogQHBhcmFtIHAxIC0gT3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMS54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMS55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMiAtIE91ciBtaWQtcG9pbnRcbiAqIEBwYXJhbSBwMi54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIG1pZC1wb2ludFxuICogQHBhcmFtIHAyLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgbWlkLXBvaW50XG4gKiBAcGFyYW0gcDMgLSBPdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBwMy54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gcDMueSAtIFRoZSB5IHZhbHVlIG9mIG91ciBmaW5hbCBwb2ludFxuXG4gKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBwMiBzaXRzIG9uIHRoZSBsaW5lIGJldHdlZW4gcDEgYW5kIHAzLlxuICovXG5leHBvcnQgY29uc3QgY2hlY2tGb3JDb2xsaW5lYXJQb2ludHMgPSAocDE6IFBvaW50LCBwMjogUG9pbnQsIHAzOiBQb2ludCkgPT5cbiAgKHAxLnkgLSBwMi55KSAqIChwMS54IC0gcDMueCkgPT09IChwMS55IC0gcDMueSkgKiAocDEueCAtIHAyLngpO1xuIiwiaW1wb3J0IHtcbiAgY2hlY2tGb3JDb2xsaW5lYXJQb2ludHMsXG4gIGdldERpc3RhbmNlQmV0d2VlbixcbiAgbW92ZVRvLFxuICBQb2ludCxcbn0gZnJvbSAnLi9tYXRoLmhlbHBlcnMnO1xuXG5leHBvcnQgY29uc3QgYnVpbGRMaW5lYXJQYXRoID0gKGRhdGE6IFBvaW50W10pID0+XG4gIGRhdGEucmVkdWNlKChwYXRoLCBwb2ludCwgaW5kZXgpID0+IHtcbiAgICAvLyBUaGUgdmVyeSBmaXJzdCBpbnN0cnVjdGlvbiBuZWVkcyB0byBiZSBhIFwibW92ZVwiLlxuICAgIC8vIFRoZSByZXN0IHdpbGwgYmUgYSBcImxpbmVcIi5cbiAgICBjb25zdCBpc0ZpcnN0SW5zdHJ1Y3Rpb24gPSBpbmRleCA9PT0gMDtcbiAgICBjb25zdCBpbnN0cnVjdGlvbiA9IGlzRmlyc3RJbnN0cnVjdGlvbiA/ICdNJyA6ICdMJztcblxuICAgIHJldHVybiBgJHtwYXRofSR7aW5zdHJ1Y3Rpb259ICR7cG9pbnQueH0sJHtwb2ludC55fVxcbmA7XG4gIH0sICcnKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU21vb3RoUGF0aChkYXRhOiBQb2ludFtdLCByYWRpdXM6IG51bWJlcikge1xuICBjb25zdCBbZmlyc3RQb2ludCwgLi4ub3RoZXJQb2ludHNdID0gZGF0YTtcblxuICByZXR1cm4gb3RoZXJQb2ludHMucmVkdWNlKChwYXRoLCBwb2ludCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBuZXh0ID0gb3RoZXJQb2ludHNbaW5kZXggKyAxXTtcbiAgICBjb25zdCBwcmV2ID0gb3RoZXJQb2ludHNbaW5kZXggLSAxXSB8fCBmaXJzdFBvaW50O1xuXG4gICAgY29uc3QgaXNDb2xsaW5lYXIgPSBuZXh0ICYmIGNoZWNrRm9yQ29sbGluZWFyUG9pbnRzKHByZXYsIHBvaW50LCBuZXh0KTtcblxuICAgIGlmICghbmV4dCB8fCBpc0NvbGxpbmVhcikge1xuICAgICAgLy8gVGhlIHZlcnkgbGFzdCBsaW5lIGluIHRoZSBzZXF1ZW5jZSBjYW4ganVzdCBiZSBhIHJlZ3VsYXIgbGluZS5cbiAgICAgIHJldHVybiBgJHtwYXRofVxcbkwgJHtwb2ludC54fSwke3BvaW50Lnl9YDtcbiAgICB9XG5cbiAgICBjb25zdCBkaXN0YW5jZUZyb21QcmV2ID0gZ2V0RGlzdGFuY2VCZXR3ZWVuKHByZXYsIHBvaW50KTtcbiAgICBjb25zdCBkaXN0YW5jZUZyb21OZXh0ID0gZ2V0RGlzdGFuY2VCZXR3ZWVuKG5leHQsIHBvaW50KTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBNYXRoLm1pbihkaXN0YW5jZUZyb21QcmV2LCBkaXN0YW5jZUZyb21OZXh0KTtcblxuICAgIGNvbnN0IGlzVG9vQ2xvc2VGb3JSYWRpdXMgPSB0aHJlc2hvbGQgLyAyIDwgcmFkaXVzO1xuXG4gICAgY29uc3QgcmFkaXVzRm9yUG9pbnQgPSBpc1Rvb0Nsb3NlRm9yUmFkaXVzID8gdGhyZXNob2xkIC8gMiA6IHJhZGl1cztcblxuICAgIGNvbnN0IGJlZm9yZSA9IG1vdmVUbyhwcmV2LCBwb2ludCwgcmFkaXVzRm9yUG9pbnQpO1xuICAgIGNvbnN0IGFmdGVyID0gbW92ZVRvKG5leHQsIHBvaW50LCByYWRpdXNGb3JQb2ludCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgcGF0aCxcbiAgICAgIGBMICR7YmVmb3JlLnh9LCR7YmVmb3JlLnl9YCxcbiAgICAgIGBTICR7cG9pbnQueH0sJHtwb2ludC55fSAke2FmdGVyLnh9LCR7YWZ0ZXIueX1gLFxuICAgIF0uam9pbignXFxuJyk7XG4gIH0sIGBNICR7Zmlyc3RQb2ludC54fSwke2ZpcnN0UG9pbnQueX1gKTtcbn1cbiIsImV4cG9ydCBjb25zdCBnZW5lcmF0ZUlkID0gKCkgPT4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMTAsIDE2KSk7XG4iLCJpbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuLi9oZWxwZXJzL21hdGguaGVscGVycyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVEYXRhc2V0KFxuICBkYXRhOiBudW1iZXJbXSxcbiAgbWluWDogbnVtYmVyLFxuICBtYXhYOiBudW1iZXIsXG4gIG1pblk6IG51bWJlcixcbiAgbWF4WTogbnVtYmVyLFxuKSB7XG4gIC8vIEZvciB0aGUgWCBheGlzLCB3ZSB3YW50IHRvIG5vcm1hbGl6ZSBpdCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gdGhlIGFycmF5LlxuICAvLyBGb3IgdGhlIFkgYXhpcywgd2Ugd2FudCB0byBub3JtYWxpemUgaXQgYmFzZWQgb24gdGhlIGVsZW1lbnQncyB2YWx1ZS5cbiAgLy9cbiAgLy8gWCBheGlzIGlzIGVhc3k6IGp1c3QgZXZlbmx5LXNwYWNlIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuXG4gIC8vIEZvciB0aGUgWSBheGlzLCB3ZSBmaXJzdCBuZWVkIHRvIGZpbmQgdGhlIG1pbiBhbmQgbWF4IG9mIG91ciBhcnJheSxcbiAgLy8gYW5kIHRoZW4gbm9ybWFsaXplIHRob3NlIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEuXG4gIGNvbnN0IGJvdW5kYXJpZXNYID0geyBtaW46IDAsIG1heDogZGF0YS5sZW5ndGggLSAxIH07XG4gIGNvbnN0IGJvdW5kYXJpZXNZID0geyBtaW46IE1hdGgubWluKC4uLmRhdGEpLCBtYXg6IE1hdGgubWF4KC4uLmRhdGEpIH07XG5cbiAgY29uc3Qgbm9ybWFsaXplZERhdGEgPSBkYXRhLm1hcCgocG9pbnQsIGluZGV4KSA9PiAoe1xuICAgIHg6IG5vcm1hbGl6ZShpbmRleCwgYm91bmRhcmllc1gubWluLCBib3VuZGFyaWVzWC5tYXgsIG1pblgsIG1heFgpLFxuICAgIHk6IG5vcm1hbGl6ZShwb2ludCwgYm91bmRhcmllc1kubWluLCBib3VuZGFyaWVzWS5tYXgsIG1pblksIG1heFkpLFxuICB9KSk7XG5cbiAgLy8gQWNjb3JkaW5nIHRvIHRoZSBTVkcgc3BlYywgcGF0aHMgd2l0aCBhIGhlaWdodC93aWR0aCBvZiBgMGAgY2FuJ3QgaGF2ZVxuICAvLyBsaW5lYXIgZ3JhZGllbnRzIGFwcGxpZWQuIFRoaXMgbWVhbnMgdGhhdCBvdXIgbGluZXMgYXJlIGludmlzaWJsZSB3aGVuXG4gIC8vIHRoZSBkYXRhc2V0IGlzIGZsYXQgKGVnLiBbMCwgMCwgMCwgMF0pLlxuICAvL1xuICAvLyBUaGUgaGFja3kgc29sdXRpb24gaXMgdG8gYXBwbHkgYSB2ZXJ5IHNsaWdodCBvZmZzZXQgdG8gdGhlIGZpcnN0IHBvaW50IG9mXG4gIC8vIHRoZSBkYXRhc2V0LiBBcyB1Z2x5IGFzIGl0IGlzLCBpdCdzIHRoZSBiZXN0IHNvbHV0aW9uIHdlIGNhbiBmaW5kICh0aGVyZVxuICAvLyBhcmUgd2F5cyB3aXRoaW4gdGhlIFNWRyBzcGVjIG9mIGNoYW5naW5nIGl0LCBidXQgbm90IHdpdGhvdXQgY2F1c2luZ1xuICAvLyBicmVha2luZyBjaGFuZ2VzKS5cbiAgaWYgKGJvdW5kYXJpZXNZLm1pbiA9PT0gYm91bmRhcmllc1kubWF4KSB7XG4gICAgbm9ybWFsaXplZERhdGFbMF0ueSArPSAwLjAwMDE7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZERhdGE7XG59XG4iLCJpbXBvcnQge1xuICBhbmltYXRlLFxuICBrZXlmcmFtZXMsXG4gIHN0YXRlLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvbixcbiAgdHJpZ2dlcixcbn0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGJ1aWxkTGluZWFyUGF0aCwgYnVpbGRTbW9vdGhQYXRoIH0gZnJvbSAnLi4vaGVscGVycy9ET00uaGVscGVycyc7XG5pbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuLi9oZWxwZXJzL21hdGguaGVscGVycyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vaGVscGVycy9taXNjLmhlbHBlcnMnO1xuaW1wb3J0IHsgbm9ybWFsaXplRGF0YXNldCB9IGZyb20gJy4vdHJlbmQuaGVscGVycyc7XG5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmd4LXRyZW5kJyxcbiAgdGVtcGxhdGU6IGBcbiAgPHN2ZyAqbmdJZj1cImRhdGEgJiYgZGF0YS5sZW5ndGggPj0gMlwiXG4gICAgW2F0dHIud2lkdGhdPVwic3ZnV2lkdGhcIlxuICAgIFthdHRyLmhlaWdodF09XCJzdmdIZWlnaHRcIlxuICAgIFthdHRyLnN0cm9rZV09XCJzdHJva2VcIlxuICAgIFthdHRyLnN0cm9rZS13aWR0aF09XCJzdHJva2VXaWR0aFwiXG4gICAgW2F0dHIuc3Ryb2tlLWxpbmVjYXBdPVwic3Ryb2tlTGluZWNhcFwiXG4gICAgW2F0dHIudmlld0JveF09XCJ2aWV3Qm94XCJcbiAgICBbYXR0ci5wcmVzZXJ2ZUFzcGVjdFJhdGlvXT1cInByZXNlcnZlQXNwZWN0UmF0aW9cIlxuICA+XG4gICAgPGRlZnMgKm5nSWY9XCJncmFkaWVudCAmJiBncmFkaWVudC5sZW5ndGhcIj5cbiAgICAgIDxsaW5lYXJHcmFkaWVudCBbYXR0ci5pZF09XCJncmFkaWVudElkXCIgeDE9XCIwJVwiIHkxPVwiMCVcIiB4Mj1cIjAlXCIgeTI9XCIxMDAlXCI+XG4gICAgICAgIDxzdG9wXG4gICAgICAgICAgKm5nRm9yPVwibGV0IGcgb2YgZ3JhZGllbnRUcmltbWVkO1wiXG4gICAgICAgICAgW2F0dHIua2V5XT1cImcuaWR4XCJcbiAgICAgICAgICBbYXR0ci5vZmZzZXRdPVwiZy5vZmZzZXRcIlxuICAgICAgICAgIFthdHRyLnN0b3AtY29sb3JdPVwiZy5zdG9wQ29sb3JcIlxuICAgICAgICAvPlxuICAgICAgPC9saW5lYXJHcmFkaWVudD5cbiAgICA8L2RlZnM+XG4gICAgPHBhdGggZmlsbD1cIm5vbmVcIiAjcGF0aEVsXG4gICAgICBbYXR0ci5zdHJva2VdPVwicGF0aFN0cm9rZVwiIFthdHRyLmRdPVwiZFwiXG4gICAgICBbQHBhdGhBbmltYWl0b25dPVwie1xuICAgICAgICB2YWx1ZTogYW5pbWF0aW9uU3RhdGUsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGF1dG9EcmF3RHVyYXRpb246IGF1dG9EcmF3RHVyYXRpb24sXG4gICAgICAgICAgYXV0b0RyYXdFYXNpbmc6IGF1dG9EcmF3RWFzaW5nLFxuICAgICAgICAgIGxpbmVMZW5ndGg6IGxpbmVMZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVwiIC8+XG4gIDwvc3ZnPlxuICBgLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcigncGF0aEFuaW1haXRvbicsIFtcbiAgICAgIHN0YXRlKCdpbmFjdGl2ZScsIHN0eWxlKHsgZGlzcGxheTogJ25vbmUnIH0pKSxcbiAgICAgIHRyYW5zaXRpb24oJyogPT4gYWN0aXZlJywgW1xuICAgICAgICBzdHlsZSh7IGRpc3BsYXk6ICdpbml0aWFsJyB9KSxcbiAgICAgICAgLy8gV2UgZG8gdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgZGFzaCBhcnJheS9vZmZzZXQgdHJpY2tcbiAgICAgICAgLy8gaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9zdmctbGluZS1hbmltYXRpb24td29ya3MvXG4gICAgICAgIGFuaW1hdGUoJ3t7IGF1dG9EcmF3RHVyYXRpb24gfX1tcyB7eyBhdXRvRHJhd0Vhc2luZyB9fScsXG4gICAgICAgICAga2V5ZnJhbWVzKFtcbiAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAne3sgbGluZUxlbmd0aCB9fXB4JyxcbiAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3t7IGxpbmVMZW5ndGggfX1weCcsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAne3sgbGluZUxlbmd0aCB9fXB4JyxcbiAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogMCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIF0pLFxuICAgICAgICApLFxuICAgICAgICAvLyBPbmUgdW5mb3J0dW5hdGUgc2lkZS1lZmZlY3Qgb2YgdGhlIGF1dG8tZHJhdyBpcyB0aGF0IHRoZSBsaW5lIGlzXG4gICAgICAgIC8vIGFjdHVhbGx5IDEgYmlnIGRhc2gsIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgbGluZSBpdHNlbGYuIElmIHRoZVxuICAgICAgICAvLyBsaW5lIGxlbmd0aCBjaGFuZ2VzIChlZy4gcmFkaXVzIGNoYW5nZSwgbmV3IGRhdGEpLCB0aGF0IGRhc2ggd29uJ3RcbiAgICAgICAgLy8gYmUgdGhlIHNhbWUgbGVuZ3RoIGFueW1vcmUuIFdlIGNhbiBmaXggdGhhdCBieSByZW1vdmluZyB0aG9zZVxuICAgICAgICAvLyBwcm9wZXJ0aWVzIG9uY2UgdGhlIGF1dG8tZHJhdyBpcyBjb21wbGV0ZWQuXG4gICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnJyxcbiAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICcnLFxuICAgICAgICB9KSxcbiAgICAgIF0pLFxuICAgIF0pLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBUcmVuZENvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIGlkOiBudW1iZXI7XG4gIEBJbnB1dCgpIGRhdGE6IChudW1iZXIgfCB7dmFsdWU6IG51bWJlcn0pW107XG4gIEBJbnB1dCgpIHNtb290aDogYm9vbGVhbjtcbiAgQElucHV0KCkgYXV0b0RyYXcgPSBmYWxzZTtcbiAgQElucHV0KCkgYXV0b0RyYXdEdXJhdGlvbiA9IDIwMDA7XG4gIEBJbnB1dCgpIGF1dG9EcmF3RWFzaW5nID0gJ2Vhc2UnO1xuICBASW5wdXQoKSB3aWR0aDogbnVtYmVyO1xuICBASW5wdXQoKSBoZWlnaHQ6IG51bWJlcjtcbiAgQElucHV0KCkgcGFkZGluZyA9IDg7XG4gIEBJbnB1dCgpIHJhZGl1cyA9IDEwO1xuICBASW5wdXQoKSBzdHJva2UgPSAnYmxhY2snO1xuICBASW5wdXQoKSBzdHJva2VMaW5lY2FwID0gJyc7XG4gIEBJbnB1dCgpIHN0cm9rZVdpZHRoID0gMTtcbiAgQElucHV0KCkgZ3JhZGllbnQ6IHN0cmluZ1tdID0gW107XG4gIEBJbnB1dCgpIHByZXNlcnZlQXNwZWN0UmF0aW86IHN0cmluZztcbiAgQElucHV0KCkgc3ZnSGVpZ2h0OiBzdHJpbmcgfCBudW1iZXIgPSAnMjUlJztcbiAgQElucHV0KCkgc3ZnV2lkdGg6IHN0cmluZyB8IG51bWJlciA9ICcxMDAlJztcbiAgQFZpZXdDaGlsZCgncGF0aEVsJykgcGF0aEVsOiBFbGVtZW50UmVmO1xuICBncmFkaWVudFRyaW1tZWQ6IGFueVtdO1xuICBkOiBhbnk7XG4gIHZpZXdCb3g6IHN0cmluZztcbiAgcGF0aFN0cm9rZTogYW55O1xuICBncmFkaWVudElkOiBzdHJpbmc7XG4gIGxpbmVMZW5ndGg6IG51bWJlcjtcbiAgYW5pbWF0aW9uU3RhdGUgPSAnJztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIHRoaXMuZ3JhZGllbnRJZCA9IGBuZ3gtdHJlbmQtdmVydGljYWwtZ3JhZGllbnQtJHt0aGlzLmlkfWA7XG4gIH1cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgLy8gV2UgbmVlZCBhdCBsZWFzdCAyIHBvaW50cyB0byBkcmF3IGEgZ3JhcGguXG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBgZGF0YWAgY2FuIGVpdGhlciBiZSBhbiBhcnJheSBvZiBudW1iZXJzOlxuICAgIC8vIFsxLCAyLCAzXVxuICAgIC8vIG9yLCBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYSB2YWx1ZTpcbiAgICAvLyBbeyB2YWx1ZTogMSB9LCB7IHZhbHVlOiAyIH0sIHsgdmFsdWU6IDMgfV1cbiAgICAvL1xuICAgIC8vIEZvciBub3csIHdlJ3JlIGp1c3QgZ29pbmcgdG8gY29udmVydCB0aGUgc2Vjb25kIGZvcm0gdG8gdGhlIGZpcnN0LlxuICAgIC8vIExhdGVyIG9uLCBpZi93aGVuIHdlIHN1cHBvcnQgdG9vbHRpcHMsIHdlIG1heSBhZGp1c3QuXG4gICAgY29uc3QgcGxhaW5WYWx1ZXMgPSB0aGlzLmRhdGEubWFwKChwb2ludCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwb2ludCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50LnZhbHVlO1xuICAgIH0pO1xuXG4gICAgLy8gT3VyIHZpZXdib3ggbmVlZHMgdG8gYmUgaW4gYWJzb2x1dGUgdW5pdHMsIHNvIHdlJ2xsIGRlZmF1bHQgdG8gMzAweDc1XG4gICAgLy8gT3VyIFNWRyBjYW4gYmUgYSAlLCB0aG91Z2g7IHRoaXMgaXMgd2hhdCBtYWtlcyBpdCBzY2FsYWJsZS5cbiAgICAvLyBCeSBkZWZhdWx0aW5nIHRvIHBlcmNlbnRhZ2VzLCB0aGUgU1ZHIHdpbGwgZ3JvdyB0byBmaWxsIGl0cyBwYXJlbnRcbiAgICAvLyBjb250YWluZXIsIHByZXNlcnZpbmcgYSAxLzQgYXNwZWN0IHJhdGlvLlxuICAgIGNvbnN0IHZpZXdCb3hXaWR0aCA9IHRoaXMud2lkdGggfHwgMzAwO1xuICAgIGNvbnN0IHZpZXdCb3hIZWlnaHQgPSB0aGlzLmhlaWdodCB8fCA3NTtcbiAgICB0aGlzLnN2Z1dpZHRoID0gdGhpcy53aWR0aCB8fCAnMTAwJSc7XG4gICAgdGhpcy5zdmdIZWlnaHQgPSB0aGlzLmhlaWdodCB8fCAnMjUlJztcbiAgICB0aGlzLnZpZXdCb3ggPSBgMCAwICR7dmlld0JveFdpZHRofSAke3ZpZXdCb3hIZWlnaHR9YDtcbiAgICBjb25zdCByb290ID0gbG9jYXRpb24uaHJlZi5zcGxpdChsb2NhdGlvbi5oYXNoIHx8ICcjJylbMF07XG4gICAgdGhpcy5wYXRoU3Ryb2tlID0gKHRoaXMuZ3JhZGllbnQgJiYgdGhpcy5ncmFkaWVudC5sZW5ndGgpID8gYHVybCgnJHtyb290fSMke3RoaXMuZ3JhZGllbnRJZH0nKWAgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmdyYWRpZW50VHJpbW1lZCA9IHRoaXMuZ3JhZGllbnQuc2xpY2UoKS5yZXZlcnNlKCkubWFwKCh2YWwsIGlkeCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWR4LFxuICAgICAgICBzdG9wQ29sb3I6IHZhbCxcbiAgICAgICAgb2Zmc2V0OiBub3JtYWxpemUoaWR4LCAwLCB0aGlzLmdyYWRpZW50Lmxlbmd0aCAtIDEgfHwgMSksXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlcyA9IG5vcm1hbGl6ZURhdGFzZXQocGxhaW5WYWx1ZXMsXG4gICAgICB0aGlzLnBhZGRpbmcsXG4gICAgICB2aWV3Qm94V2lkdGggLSB0aGlzLnBhZGRpbmcsXG4gICAgICAvLyBOT1RFOiBCZWNhdXNlIFNWR3MgYXJlIGluZGV4ZWQgZnJvbSB0aGUgdG9wIGxlZnQsIGJ1dCBtb3N0IGRhdGEgaXNcbiAgICAgIC8vIGluZGV4ZWQgZnJvbSB0aGUgYm90dG9tIGxlZnQsIHdlJ3JlIGludmVydGluZyB0aGUgWSBtaW4vbWF4LlxuICAgICAgdmlld0JveEhlaWdodCAtIHRoaXMucGFkZGluZyxcbiAgICAgIHRoaXMucGFkZGluZyxcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuYXV0b0RyYXcgJiYgdGhpcy5hbmltYXRpb25TdGF0ZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSAnaW5hY3RpdmUnO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IHRoaXMucGF0aEVsLm5hdGl2ZUVsZW1lbnQuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9ICdhY3RpdmUnO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5kID0gdGhpcy5zbW9vdGhcbiAgICAgID8gYnVpbGRTbW9vdGhQYXRoKG5vcm1hbGl6ZWRWYWx1ZXMsIHRoaXMucmFkaXVzKVxuICAgICAgOiBidWlsZExpbmVhclBhdGgobm9ybWFsaXplZFZhbHVlcyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBUcmVuZENvbXBvbmVudCB9IGZyb20gJy4vdHJlbmQuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGV4cG9ydHM6IFtUcmVuZENvbXBvbmVudF0sXG4gIGRlY2xhcmF0aW9uczogW1RyZW5kQ29tcG9uZW50XSxcbn0pXG5leHBvcnQgY2xhc3MgVHJlbmRNb2R1bGUge1xufVxuIl0sIm5hbWVzIjpbIkNvbXBvbmVudCIsInRyaWdnZXIiLCJzdGF0ZSIsInN0eWxlIiwidHJhbnNpdGlvbiIsImFuaW1hdGUiLCJrZXlmcmFtZXMiLCJJbnB1dCIsIlZpZXdDaGlsZCIsIk5nTW9kdWxlIiwiQ29tbW9uTW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7SUFBQTs7Ozs7Ozs7Ozs7Ozs7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